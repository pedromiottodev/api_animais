Onde:

routes.js â†’ define as rotas (GET, POST, PUT, DELETE) com funÃ§Ãµes bem simples

app.js â†’ sobe o servidor e usa o roteador

Tudo usando sÃ³ import/export padrÃ£o, sem complicaÃ§Ã£o.

RODANDO O ARQUIVO: node src/app.js ou npx nodemon src/app.js


Primeiro passo:
criar uma pasta package.json atravÃ©s de npm init -y

O que faz?
Cria o arquivo package.json, que:

Diz que este diretÃ³rio Ã© um projeto Node.js

Armazena as dependÃªncias do projeto

Guarda os scripts que usamos com npm run

O -y?
Aceita todas as opÃ§Ãµes padrÃ£o (nome, versÃ£o, etc.)

VocÃª pode editar depois

---------------------------------------------------------------------------------------------------------------------------------------------------

Segundo passo:
instalar o express atravÃ©s de npm install express

O que faz?
Instala o Express, que Ã© o micro framework que usamos para:

Criar o servidor

Criar rotas HTTP

Lidar com requisiÃ§Ãµes/respostas de forma fÃ¡cil

---------------------------------------------------------------------------------------------------------------------------------------------------

Terceiro passo:
instalar o nodemon para o servidor recarregar sozinho quando salvar atravÃ©s de npm install nodemon -D (-D pq serÃ¡ uma dependÃªncia de desenvolvimento, nÃ£o queremos que vÃ¡ para produÃ§Ã£o)

O que Ã© nodemon?
Ã‰ um utilitÃ¡rio que reinicia o servidor automaticamente sempre que um arquivo muda.

Assim vocÃª nÃ£o precisa toda hora parar e rodar de novo node app.js.

E o -D?
Significa:

â€œInstala como dependÃªncia de desenvolvimentoâ€

Ou seja:

nodemon sÃ³ Ã© usado durante o desenvolvimento

Ele nÃ£o vai ser necessÃ¡rio em produÃ§Ã£o (quando o projeto estiver rodando em um servidor real)

---------------------------------------------------------------------------------------------------------------------------------------------------

Quarto passo:
configurar o package.json para usar import/export
"type": "module"

"type": "module" no package.json
Por que isso?
O Node.js por padrÃ£o usa o sistema antigo de mÃ³dulos:

const express = require('express')
Mas com "type": "module", a gente diz pro Node:

"Queremos usar o sistema moderno de mÃ³dulos do JavaScript (ES Modules)"

Ou seja, com isso a gente pode usar:
import express from 'express'
export default ...
âœ… Mais limpo, mais moderno e Ã© o padrÃ£o atual de bibliotecas.

---------------------------------------------------------------------------------------------------------------------------------------------------

Quinto passo:
scripts": { "dev": "nodemon src/app.js" }
Pra que isso?
Assim vocÃª pode rodar o projeto com:

npm run dev
Ao invÃ©s de digitar npx nodemon src/app.js toda vez.

Ã‰ um atalho, um script personalizado.

O que Ã© um Middleware?
âœ… DefiniÃ§Ã£o simples:
Um middleware Ã© uma funÃ§Ã£o intermediÃ¡ria que roda antes de chegar na rota final.

Ela pode:

Verificar algo (ex: validaÃ§Ã£o, autenticaÃ§Ã£o)

Modificar a requisiÃ§Ã£o (req) ou a resposta (res)

Bloquear ou deixar passar

Chamar a prÃ³xima etapa com next()

Em cÃ³digo, a estrutura de um middleware Ã©:
function nomeDoMiddleware(req, res, next) {
  // faz algo com req ou res

  // se estiver tudo certo, deixa seguir
  next()
}

tapa 5 â€“ IntegraÃ§Ã£o com Banco de Dados
ğŸ“¦ Tecnologias que vamos usar:
SQLite: banco leve, nÃ£o precisa instalar nada externo

Prisma ORM: pra manipular o banco de forma simples e organizada

ğŸ§° Etapas da configuraÃ§Ã£o:
âœ… 1. Instalar o Prisma
No terminal, dentro da pasta do seu projeto:

npm install prisma --save-dev
npx prisma init
Isso vai criar uma pasta chamada prisma/ com o arquivo schema.prisma, e o .env.

âœ… 2. Instalar o cliente Prisma

npm install @prisma/client
Esse Ã© quem vai permitir que sua aplicaÃ§Ã£o se conecte ao banco.

âœ… 3. Configurar o banco no .env
Abra o arquivo .env que foi criado e altere a linha:

DATABASE_URL="file:./dev.db"
Pode deixar exatamente assim, ele criarÃ¡ um arquivo dev.db dentro da pasta do projeto.


O que Ã© prisma?
O Prisma Ã© uma ferramenta que ajuda a gente a conversar com o banco de dados usando JavaScript/Node.
Sem Prisma, vocÃª teria que escrever comandos como:
INSERT INTO tarefas (titulo, descricao, concluida) VALUES (...)
Com o Prisma, a gente usa comandos em JavaScript, tipo:
prisma.tarefa.create({...})

O que Ã© uma migraÃ§Ã£o no contexto de banco de dados?
MigraÃ§Ã£o Ã© um registro de mudanÃ§a na estrutura do banco de dados.

Sempre que vocÃª altera o que existe no banco (como criar uma tabela, renomear um campo, adicionar uma coluna), vocÃª precisa "migrar" essa alteraÃ§Ã£o para o banco de dados real.

ğŸ“¦ Exemplo prÃ¡tico:
VocÃª escreve isso no schema.prisma:

prisma

model Tarefa {
  id         Int      @id @default(autoincrement())
  titulo     String
  descricao  String
  concluido  Boolean  @default(false)
}
Mas o banco ainda estÃ¡ assim:

id | titulo | descricao | concluida
Ou seja, o banco ainda tem concluida com â€œaâ€, e nÃ£o tem o campo concluido.

ğŸ› ï¸ O que a migraÃ§Ã£o faz?
Quando vocÃª roda:

npx prisma migrate dev --name renomear_concluida
O Prisma:

Detecta a diferenÃ§a entre seu schema atual e o banco

Gera um script SQL pra corrigir isso

Executa esse script e atualiza o banco de dados real

ğŸ§  Analogia simples:
O schema.prisma Ã© o projeto arquitetÃ´nico da sua casa.
A migraÃ§Ã£o Ã© o pedreiro executando as mudanÃ§as (levantar parede nova, quebrar outra, etc).

âœ… Quando vocÃª faz uma migraÃ§Ã£o?
Criou um model novo? â†’ precisa migrar.

Adicionou um campo? â†’ precisa migrar.

Mudou o nome de um campo? â†’ precisa migrar.

Apagou uma coluna? â†’ precisa migrar.

ğŸ“ Onde ficam armazenadas?
O Prisma guarda cada migraÃ§Ã£o em uma pasta prisma/migrations/, com o nome que vocÃª escolheu, tipo:

prisma/migrations/20250429_renomear_concluida/
Assim vocÃª tem um histÃ³rico de tudo que jÃ¡ mudou no banco.

âœ… Resumo final:
Conceito	O que Ã©
MigraÃ§Ã£o	AtualizaÃ§Ã£o da estrutura do banco baseada no schema.prisma
Quando usar	Sempre que mudar o model no schema.prisma
Como rodar	npx prisma migrate dev --name nome_da_migracao


TypeScript
npm install typescript -D
VocÃª pode agora criar o tsconfig.json npx tsc --init


O que Ã© o tsconfig.json?
Ã‰ um arquivo de configuraÃ§Ã£o do TypeScript. Ele diz ao compilador tsc como ele deve converter seus arquivos .ts para .js.

Pensa nele como um manual de instruÃ§Ãµes que o TypeScript segue durante a compilaÃ§Ã£o.

ğŸ§  Por que ele Ã© necessÃ¡rio?
Sem esse arquivo, o TypeScript usa configuraÃ§Ãµes padrÃ£o (e bem limitadas). Isso pode causar:

Falta de controle sobre o nÃ­vel de verificaÃ§Ã£o dos tipos

Problemas na hora de escolher a pasta de entrada (src) e saÃ­da (dist)

Dificuldade pra usar recursos mais modernos do JS/TS (como decorators, mÃ³dulos, paths personalizados etc)

Com o tsconfig.json, vocÃª pode personalizar tudo isso: o que compilar, onde salvar, que padrÃ£o JS usar, quais regras seguir, e muito mais.

{
  "compilerOptions": {
    "target": "ES2020",                 // versÃ£o do JS gerado
    "module": "commonjs",               // tipo de mÃ³dulo (Node usa commonjs)
    "rootDir": "./src",                 // onde ficam os arquivos .ts
    "outDir": "./dist",                 // onde os .js compilados vÃ£o parar
    "strict": true,                     // ativa vÃ¡rias verificaÃ§Ãµes de tipo
    "esModuleInterop": true,           // permite importar mÃ³dulos commonjs com "import"
    "forceConsistentCasingInFileNames": true // evita bugs com maiÃºsculas/minÃºsculas em arquivos
  },
  "include": ["src"]
}

O que Ã© npx?
O npx Ã© um executador de pacotes do Node.js.

Ele permite rodar pacotes diretamente do npm sem precisar instalÃ¡-los globalmente.

DiferenÃ§a entre npm e npx
Comando 	Serve para...	Exemplo
npm	        Instalar        pacotes no seu projeto ou globalmente	npm install typescript -D
npx	        Executar        pacotes (mesmo se nÃ£o estiverem instalados globalmente)	npx tsc --init

Rodar seu projeto com:
npm run dev
Ou seja, ao invÃ©s de compilar manualmente (npx tsc) e depois rodar com node dist/servidor.js, a gente vai automatizar esse processo em um comando sÃ³.

Etapa 1 â€” Instalar o ts-node-dev
ğŸ“Œ O que Ã©:
Ã‰ um pacote que:

Compila e executa seu .ts direto, sem gerar arquivos .js

Recarrega o servidor automaticamente sempre que vocÃª salva um arquivo (igual ao Nodemon)
npm install ts-node-dev -D

Por que:
Evita o passo manual de compilar (npx tsc)

Deixa o desenvolvimento mais rÃ¡pido, com recarregamento automÃ¡tico

Etapa 2 â€” Adicionar script no package.json

Abra seu package.json e adicione (ou edite) a parte "scripts" assim:
"scripts": {
  "dev": "ts-node-dev --respawn --transpile-only src/servidor.ts"
}

O que isso faz:
"dev" â†’ Ã© o nome do script, vocÃª vai rodar com npm run dev

ts-node-dev â†’ roda arquivos .ts sem compilar

--respawn â†’ reinicia o processo sempre que o cÃ³digo muda

--transpile-only â†’ transpila mais rÃ¡pido (sem checagens de tipo pesadas)

src/servidor.ts â†’ Ã© o arquivo principal da sua API

Configurando o express com suporte ao typescript
apÃ³s o express e ts estarem instalados devemos instalar os tipos do express.
npm install @types/express -D

Por que:
O TypeScript nÃ£o "entende" bibliotecas JS puras por padrÃ£o. Os @types sÃ£o arquivos que descrevem as tipagens do Express, permitindo:

Autocompletar no VS Code

Checagens de erro

Boa documentaÃ§Ã£o inline

nesta linha: import express, { Request, Response } from "express"
por que Request e Response ficam entre chaves?

express Ã© o export default do pacote.

{ Request, Response } sÃ£o exportaÃ§Ãµes nomeadas (ou "named exports").

O que sÃ£o "exportaÃ§Ãµes nomeadas"?
SÃ£o funcionalidades que um mÃ³dulo exporta com nome fixo. VocÃª precisa importar com exatamente o mesmo nome.

No caso do pacote express, ele exporta vÃ¡rias coisas, incluindo:

Request

Response

Router

NextFunction

...

Esses sÃ£o tipos (ou funÃ§Ãµes, ou constantes) exportados de forma nomeada, entÃ£o vocÃª precisa usar chaves para dizer exatamente o que quer importar.

 Comparando com e sem chaves
âœ… Com chaves (named exports):
import { Request, Response } from "express"
VocÃª estÃ¡ dizendo: â€œme dÃ¡ especificamente Request e Responseâ€.

Sem chaves (default export):
import express from "express"
Aqui vocÃª estÃ¡ pegando o valor padrÃ£o exportado pelo mÃ³dulo (o prÃ³prio express()).

Analogia:
Imagina que o mÃ³dulo express Ã© uma caixa com:

Um item principal (o prÃ³prio express)

E vÃ¡rios acessÃ³rios com nome (Request, Response, Routerâ€¦)

Se vocÃª quiser sÃ³ o item principal:
import express from "express"

Se quiser acessÃ³rios especÃ­ficos:
import { Request, Response } from "express"

Se quiser os dois: usa os dois juntos, como vocÃª fez:
import express, { Request, Response } from "express"

Podemos importar o express com import express from "express" porque ele exporta uma funÃ§Ã£o principal (default).
AlÃ©m disso, o pacote tambÃ©m exporta outros elementos com nomes fixos (como Request, Response), que sÃ£o usados separadamente e precisam ser importados com chaves {}.

Controller
controller Ã© onde fazemos as validaÃ§Ãµes daquela rota, certo?
se o usuÃ¡rio nos mandou a informaÃ§Ã£o que precisavÃ¡mos, se estÃ¡ nulo, etc...


ChatGPT said:
Exatamente, Pedro! Ã‰ isso mesmo ğŸ‘
O controller Ã© onde vocÃª faz a lÃ³gica daquela rota, e isso inclui:

âœ… O que vai num controller?
ValidaÃ§Ãµes iniciais dos dados

Ex: verificar se o campo nome veio preenchido

Ver se um id existe antes de buscar no banco

LÃ³gica de negÃ³cio

Ex: cadastrar um novo usuÃ¡rio

Buscar todos os animais disponÃ­veis

Verificar se jÃ¡ existe um e-mail no sistema

Respostas da API

Ex: retornar 200 OK, 201 Created, 400 Bad Request, 404 Not Found, etc.

âŒ O que nÃ£o vai no controller:
Definir rotas (router.get, router.post) â†’ isso fica nas rotas

ConexÃ£o direta com o servidor (listen, middlewares globais) â†’ isso fica no servidor.ts


INSTALANDO PRISMA E MYSQL

Integrar o projeto com Prisma e MySQL, para que os dados de usuÃ¡rios e animais:

nÃ£o fiquem mais simulados,

sejam armazenados de verdade em um banco de dados,

possam ser listados, buscados, atualizados ou deletados mais tarde.

Etapa 1: Instalar o Prisma no projeto
ğŸ“¦ Por que estamos instalando o Prisma?
O Prisma Ã© uma ferramenta que facilita a comunicaÃ§Ã£o entre o cÃ³digo e o banco de dados.
Ele traduz os comandos JS/TS para comandos SQL, alÃ©m de gerar tipos automÃ¡ticos pro TypeScript.

npm install prisma -D

Depois, precisamos tambÃ©m instalar o Prisma Client (essa parte vai pro cÃ³digo em produÃ§Ã£o):
npm install @prisma/client

Por que isso?
Porque o @prisma/client Ã© a biblioteca que seu cÃ³digo vai usar pra interagir com o banco.

âœ… Etapa 2: Inicializar o Prisma no projeto
ğŸ¯ O que vamos fazer:
Rodar o comando npx prisma init, que vai criar a estrutura inicial do Prisma no projeto.

ğŸ“¦ O que esse comando faz:
npx prisma init
Ele vai criar dois arquivos/pastas:

.env â†’ onde colocamos a string de conexÃ£o com o banco de dados

prisma/schema.prisma â†’ onde vocÃª define as tabelas do banco usando a linguagem do Prisma (super simples de ler)

ğŸ§  Por que isso Ã© importante?
O arquivo schema.prisma Ã© onde vocÃª descreve os modelos do seu banco â€” tipo User, Animal, etc.

A partir disso, o Prisma:

Cria as tabelas no banco

Gera o cÃ³digo necessÃ¡rio pra vocÃª usar essas tabelas no TypeScript

âœ… Etapa 3: Entendendo os arquivos criados
ApÃ³s rodar npx prisma init, ele criou:

ğŸ“ prisma/schema.prisma
Onde vocÃª define os modelos do seu banco â€” como se fossem as â€œtabelasâ€ ou â€œentidadesâ€.

Aqui vocÃª vai escrever algo como:
model Usuario {
  id    Int     @id @default(autoincrement())
  nome  String
  email String  @unique
}

Esse arquivo vai guiar:

a criaÃ§Ã£o das tabelas no banco,

e a geraÃ§Ã£o dos mÃ©todos que vocÃª usarÃ¡ no cÃ³digo (tipo prisma.usuario.findMany())

.env
Arquivo para armazenar variÃ¡veis sensÃ­veis e de ambiente, como a string de conexÃ£o com o banco.

Por padrÃ£o, ele jÃ¡ tem uma linha assim:
DATABASE_URL="mysql://usuario:senha@localhost:3306/nome_do_banco"
VocÃª vai ajustar isso pra conectar com seu MySQL.

âœ… Etapa 5: Criar o banco api_animais
ğŸ“Œ Por que criar esse banco?
Porque o Prisma precisa que o banco jÃ¡ exista antes de gerar as tabelas com migrate.

ğŸ›  Como criar o banco
VocÃª pode fazer isso de 2 formas:

ğŸ’» OpÃ§Ã£o 1: pelo MySQL Workbench (mais visual)
Abre o MySQL Workbench

Clique em Local instance MySQL (ou similar)

Digite a senha de root que vocÃª escolheu

Quando conectar, vÃ¡ no canto esquerdo â†’ clique com o botÃ£o direito em Schemas

Clique em "Create Schema..."

Nomeie como: api_animais

Clique em Apply â†’ depois em Finish

ğŸ–¥ï¸ OpÃ§Ã£o 2: via terminal (mais direto)

1: Rode
mysql -u root -p

2: Digite a senha

3: Depois rode:
CREATE DATABASE api_animais;

Etapa 8: Rodar a migraÃ§Ã£o com Prisma
Agora vamos rodar o comando que:

Cria as tabelas Usuario e Animal dentro do banco api_animais

Gera o Prisma Client, que Ã© o cÃ³digo que vocÃª vai usar no seu projeto pra acessar esses dados

 O que Ã© uma migraÃ§Ã£o?
MigraÃ§Ã£o (ou migration) Ã© um registro das mudanÃ§as na estrutura do banco de dados ao longo do tempo.

ğŸ§  Pense assim:
Seu schema.prisma define o modelo do banco no cÃ³digo.

A migraÃ§Ã£o:

compara o que estÃ¡ no cÃ³digo com o que estÃ¡ no banco

gera instruÃ§Ãµes SQL pra aplicar essa mudanÃ§a no banco

e guarda isso num arquivo de controle

âœ… Por que usar migraÃ§Ã£o?
Vantagem	ExplicaÃ§Ã£o
Controle de versÃ£o	Sabe quando e por que uma tabela foi criada, alterada, etc.
Trabalho em equipe	Todos os devs aplicam a mesma estrutura, na mesma ordem
SeguranÃ§a	Evita alterar tabelas manualmente no banco e esquecer
Rollback	VocÃª pode desfazer mudanÃ§as se der problema

ğŸ—‚ï¸ No Prisma:
As migraÃ§Ãµes ficam salvas na pasta prisma/migrations

Cada pasta tem data, nome (init, add-animais, etc.) e um .sql gerado automaticamente

âœ… Etapa 8: Rodar a migraÃ§Ã£o com Prisma
Agora vamos rodar o comando que:

Cria as tabelas Usuario e Animal dentro do banco api_animais

Gera o Prisma Client, que Ã© o cÃ³digo que vocÃª vai usar no seu projeto pra acessar esses dados

ğŸ“¦ Comando:
npx prisma migrate dev --name init

ğŸ§  O que esse comando faz?
migrate dev: executa a criaÃ§Ã£o das tabelas com base no schema.prisma

--name init: dÃ¡ um nome pra essa â€œversÃ£oâ€ do banco (pode ser qualquer nome, tipo init, primeira-migracao, etc.)

Esse comando tambÃ©m atualiza o Prisma Client automaticamente, entÃ£o vocÃª jÃ¡ pode usar ele no seu cÃ³digo.

âœ… O que esperar:
Uma pasta prisma/migrations serÃ¡ criada com os arquivos de controle da estrutura do banco

Uma mensagem tipo:
âœ” The following migration(s) have been applied: ...

E seu banco api_animais estarÃ¡ com as tabelas prontas