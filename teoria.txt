Onde:

routes.js ‚Üí define as rotas (GET, POST, PUT, DELETE) com fun√ß√µes bem simples

app.js ‚Üí sobe o servidor e usa o roteador

Tudo usando s√≥ import/export padr√£o, sem complica√ß√£o.

RODANDO O ARQUIVO: node src/app.js ou npx nodemon src/app.js


Primeiro passo:
criar uma pasta package.json atrav√©s de npm init -y

O que faz?
Cria o arquivo package.json, que:

Diz que este diret√≥rio √© um projeto Node.js

Armazena as depend√™ncias do projeto

Guarda os scripts que usamos com npm run

O -y?
Aceita todas as op√ß√µes padr√£o (nome, vers√£o, etc.)

Voc√™ pode editar depois

---------------------------------------------------------------------------------------------------------------------------------------------------

Segundo passo:
instalar o express atrav√©s de npm install express

O que faz?
Instala o Express, que √© o micro framework que usamos para:

Criar o servidor

Criar rotas HTTP

Lidar com requisi√ß√µes/respostas de forma f√°cil

---------------------------------------------------------------------------------------------------------------------------------------------------

Terceiro passo:
instalar o nodemon para o servidor recarregar sozinho quando salvar atrav√©s de npm install nodemon -D (-D pq ser√° uma depend√™ncia de desenvolvimento, n√£o queremos que v√° para produ√ß√£o)

O que √© nodemon?
√â um utilit√°rio que reinicia o servidor automaticamente sempre que um arquivo muda.

Assim voc√™ n√£o precisa toda hora parar e rodar de novo node app.js.

E o -D?
Significa:

‚ÄúInstala como depend√™ncia de desenvolvimento‚Äù

Ou seja:

nodemon s√≥ √© usado durante o desenvolvimento

Ele n√£o vai ser necess√°rio em produ√ß√£o (quando o projeto estiver rodando em um servidor real)

---------------------------------------------------------------------------------------------------------------------------------------------------

Quarto passo:
configurar o package.json para usar import/export
"type": "module"

"type": "module" no package.json
Por que isso?
O Node.js por padr√£o usa o sistema antigo de m√≥dulos:

const express = require('express')
Mas com "type": "module", a gente diz pro Node:

"Queremos usar o sistema moderno de m√≥dulos do JavaScript (ES Modules)"

Ou seja, com isso a gente pode usar:
import express from 'express'
export default ...
‚úÖ Mais limpo, mais moderno e √© o padr√£o atual de bibliotecas.

---------------------------------------------------------------------------------------------------------------------------------------------------

Quinto passo:
scripts": { "dev": "nodemon src/app.js" }
Pra que isso?
Assim voc√™ pode rodar o projeto com:

npm run dev
Ao inv√©s de digitar npx nodemon src/app.js toda vez.

√â um atalho, um script personalizado.

O que √© um Middleware?
‚úÖ Defini√ß√£o simples:
Um middleware √© uma fun√ß√£o intermedi√°ria que roda antes de chegar na rota final.

Ela pode:

Verificar algo (ex: valida√ß√£o, autentica√ß√£o)

Modificar a requisi√ß√£o (req) ou a resposta (res)

Bloquear ou deixar passar

Chamar a pr√≥xima etapa com next()

Em c√≥digo, a estrutura de um middleware √©:
function nomeDoMiddleware(req, res, next) {
  // faz algo com req ou res

  // se estiver tudo certo, deixa seguir
  next()
}

tapa 5 ‚Äì Integra√ß√£o com Banco de Dados
üì¶ Tecnologias que vamos usar:
SQLite: banco leve, n√£o precisa instalar nada externo

Prisma ORM: pra manipular o banco de forma simples e organizada

üß∞ Etapas da configura√ß√£o:
‚úÖ 1. Instalar o Prisma
No terminal, dentro da pasta do seu projeto:

npm install prisma --save-dev
npx prisma init
Isso vai criar uma pasta chamada prisma/ com o arquivo schema.prisma, e o .env.

‚úÖ 2. Instalar o cliente Prisma

npm install @prisma/client
Esse √© quem vai permitir que sua aplica√ß√£o se conecte ao banco.

‚úÖ 3. Configurar o banco no .env
Abra o arquivo .env que foi criado e altere a linha:

DATABASE_URL="file:./dev.db"
Pode deixar exatamente assim, ele criar√° um arquivo dev.db dentro da pasta do projeto.


O que √© prisma?
O Prisma √© uma ferramenta que ajuda a gente a conversar com o banco de dados usando JavaScript/Node.
Sem Prisma, voc√™ teria que escrever comandos como:
INSERT INTO tarefas (titulo, descricao, concluida) VALUES (...)
Com o Prisma, a gente usa comandos em JavaScript, tipo:
prisma.tarefa.create({...})

O que √© uma migra√ß√£o no contexto de banco de dados?
Migra√ß√£o √© um registro de mudan√ßa na estrutura do banco de dados.

Sempre que voc√™ altera o que existe no banco (como criar uma tabela, renomear um campo, adicionar uma coluna), voc√™ precisa "migrar" essa altera√ß√£o para o banco de dados real.

üì¶ Exemplo pr√°tico:
Voc√™ escreve isso no schema.prisma:

prisma

model Tarefa {
  id         Int      @id @default(autoincrement())
  titulo     String
  descricao  String
  concluido  Boolean  @default(false)
}
Mas o banco ainda est√° assim:

id | titulo | descricao | concluida
Ou seja, o banco ainda tem concluida com ‚Äúa‚Äù, e n√£o tem o campo concluido.

üõ†Ô∏è O que a migra√ß√£o faz?
Quando voc√™ roda:

npx prisma migrate dev --name renomear_concluida
O Prisma:

Detecta a diferen√ßa entre seu schema atual e o banco

Gera um script SQL pra corrigir isso

Executa esse script e atualiza o banco de dados real

üß† Analogia simples:
O schema.prisma √© o projeto arquitet√¥nico da sua casa.
A migra√ß√£o √© o pedreiro executando as mudan√ßas (levantar parede nova, quebrar outra, etc).

‚úÖ Quando voc√™ faz uma migra√ß√£o?
Criou um model novo? ‚Üí precisa migrar.

Adicionou um campo? ‚Üí precisa migrar.

Mudou o nome de um campo? ‚Üí precisa migrar.

Apagou uma coluna? ‚Üí precisa migrar.

üìÅ Onde ficam armazenadas?
O Prisma guarda cada migra√ß√£o em uma pasta prisma/migrations/, com o nome que voc√™ escolheu, tipo:

prisma/migrations/20250429_renomear_concluida/
Assim voc√™ tem um hist√≥rico de tudo que j√° mudou no banco.

‚úÖ Resumo final:
Conceito	O que √©
Migra√ß√£o	Atualiza√ß√£o da estrutura do banco baseada no schema.prisma
Quando usar	Sempre que mudar o model no schema.prisma
Como rodar	npx prisma migrate dev --name nome_da_migracao


TypeScript
npm install typescript -D
Voc√™ pode agora criar o tsconfig.json npx tsc --init


O que √© o tsconfig.json?
√â um arquivo de configura√ß√£o do TypeScript. Ele diz ao compilador tsc como ele deve converter seus arquivos .ts para .js.

Pensa nele como um manual de instru√ß√µes que o TypeScript segue durante a compila√ß√£o.

üß† Por que ele √© necess√°rio?
Sem esse arquivo, o TypeScript usa configura√ß√µes padr√£o (e bem limitadas). Isso pode causar:

Falta de controle sobre o n√≠vel de verifica√ß√£o dos tipos

Problemas na hora de escolher a pasta de entrada (src) e sa√≠da (dist)

Dificuldade pra usar recursos mais modernos do JS/TS (como decorators, m√≥dulos, paths personalizados etc)

Com o tsconfig.json, voc√™ pode personalizar tudo isso: o que compilar, onde salvar, que padr√£o JS usar, quais regras seguir, e muito mais.

{
  "compilerOptions": {
    "target": "ES2020",                 // vers√£o do JS gerado
    "module": "commonjs",               // tipo de m√≥dulo (Node usa commonjs)
    "rootDir": "./src",                 // onde ficam os arquivos .ts
    "outDir": "./dist",                 // onde os .js compilados v√£o parar
    "strict": true,                     // ativa v√°rias verifica√ß√µes de tipo
    "esModuleInterop": true,           // permite importar m√≥dulos commonjs com "import"
    "forceConsistentCasingInFileNames": true // evita bugs com mai√∫sculas/min√∫sculas em arquivos
  },
  "include": ["src"]
}

O que √© npx?
O npx √© um executador de pacotes do Node.js.

Ele permite rodar pacotes diretamente do npm sem precisar instal√°-los globalmente.

Diferen√ßa entre npm e npx
Comando 	Serve para...	Exemplo
npm	        Instalar        pacotes no seu projeto ou globalmente	npm install typescript -D
npx	        Executar        pacotes (mesmo se n√£o estiverem instalados globalmente)	npx tsc --init

Rodar seu projeto com:
npm run dev
Ou seja, ao inv√©s de compilar manualmente (npx tsc) e depois rodar com node dist/servidor.js, a gente vai automatizar esse processo em um comando s√≥.

Etapa 1 ‚Äî Instalar o ts-node-dev
üìå O que √©:
√â um pacote que:

Compila e executa seu .ts direto, sem gerar arquivos .js

Recarrega o servidor automaticamente sempre que voc√™ salva um arquivo (igual ao Nodemon)
npm install ts-node-dev -D

Por que:
Evita o passo manual de compilar (npx tsc)

Deixa o desenvolvimento mais r√°pido, com recarregamento autom√°tico

Etapa 2 ‚Äî Adicionar script no package.json

Abra seu package.json e adicione (ou edite) a parte "scripts" assim:
"scripts": {
  "dev": "ts-node-dev --respawn --transpile-only src/servidor.ts"
}

O que isso faz:
"dev" ‚Üí √© o nome do script, voc√™ vai rodar com npm run dev

ts-node-dev ‚Üí roda arquivos .ts sem compilar

--respawn ‚Üí reinicia o processo sempre que o c√≥digo muda

--transpile-only ‚Üí transpila mais r√°pido (sem checagens de tipo pesadas)

src/servidor.ts ‚Üí √© o arquivo principal da sua API

Configurando o express com suporte ao typescript
ap√≥s o express e ts estarem instalados devemos instalar os tipos do express.
npm install @types/express -D

Por que:
O TypeScript n√£o "entende" bibliotecas JS puras por padr√£o. Os @types s√£o arquivos que descrevem as tipagens do Express, permitindo:

Autocompletar no VS Code

Checagens de erro

Boa documenta√ß√£o inline

nesta linha: import express, { Request, Response } from "express"
por que Request e Response ficam entre chaves?

express √© o export default do pacote.

{ Request, Response } s√£o exporta√ß√µes nomeadas (ou "named exports").

O que s√£o "exporta√ß√µes nomeadas"?
S√£o funcionalidades que um m√≥dulo exporta com nome fixo. Voc√™ precisa importar com exatamente o mesmo nome.

No caso do pacote express, ele exporta v√°rias coisas, incluindo:

Request

Response

Router

NextFunction

...

Esses s√£o tipos (ou fun√ß√µes, ou constantes) exportados de forma nomeada, ent√£o voc√™ precisa usar chaves para dizer exatamente o que quer importar.

 Comparando com e sem chaves
‚úÖ Com chaves (named exports):
import { Request, Response } from "express"
Voc√™ est√° dizendo: ‚Äúme d√° especificamente Request e Response‚Äù.

Sem chaves (default export):
import express from "express"
Aqui voc√™ est√° pegando o valor padr√£o exportado pelo m√≥dulo (o pr√≥prio express()).

Analogia:
Imagina que o m√≥dulo express √© uma caixa com:

Um item principal (o pr√≥prio express)

E v√°rios acess√≥rios com nome (Request, Response, Router‚Ä¶)

Se voc√™ quiser s√≥ o item principal:
import express from "express"

Se quiser acess√≥rios espec√≠ficos:
import { Request, Response } from "express"

Se quiser os dois: usa os dois juntos, como voc√™ fez:
import express, { Request, Response } from "express"

Podemos importar o express com import express from "express" porque ele exporta uma fun√ß√£o principal (default).
Al√©m disso, o pacote tamb√©m exporta outros elementos com nomes fixos (como Request, Response), que s√£o usados separadamente e precisam ser importados com chaves {}.

Controller
controller √© onde fazemos as valida√ß√µes daquela rota, certo?
se o usu√°rio nos mandou a informa√ß√£o que precisav√°mos, se est√° nulo, etc...


ChatGPT said:
Exatamente, Pedro! √â isso mesmo üëè
O controller √© onde voc√™ faz a l√≥gica daquela rota, e isso inclui:

‚úÖ O que vai num controller?
Valida√ß√µes iniciais dos dados

Ex: verificar se o campo nome veio preenchido

Ver se um id existe antes de buscar no banco

L√≥gica de neg√≥cio

Ex: cadastrar um novo usu√°rio

Buscar todos os animais dispon√≠veis

Verificar se j√° existe um e-mail no sistema

Respostas da API

Ex: retornar 200 OK, 201 Created, 400 Bad Request, 404 Not Found, etc.

‚ùå O que n√£o vai no controller:
Definir rotas (router.get, router.post) ‚Üí isso fica nas rotas

Conex√£o direta com o servidor (listen, middlewares globais) ‚Üí isso fica no servidor.ts


INSTALANDO PRISMA E MYSQL

Integrar o projeto com Prisma e MySQL, para que os dados de usu√°rios e animais:

n√£o fiquem mais simulados,

sejam armazenados de verdade em um banco de dados,

possam ser listados, buscados, atualizados ou deletados mais tarde.

Etapa 1: Instalar o Prisma no projeto
üì¶ Por que estamos instalando o Prisma?
O Prisma √© uma ferramenta que facilita a comunica√ß√£o entre o c√≥digo e o banco de dados.
Ele traduz os comandos JS/TS para comandos SQL, al√©m de gerar tipos autom√°ticos pro TypeScript.

npm install prisma -D

Depois, precisamos tamb√©m instalar o Prisma Client (essa parte vai pro c√≥digo em produ√ß√£o):
npm install @prisma/client

Por que isso?
Porque o @prisma/client √© a biblioteca que seu c√≥digo vai usar pra interagir com o banco.

‚úÖ Etapa 2: Inicializar o Prisma no projeto
üéØ O que vamos fazer:
Rodar o comando npx prisma init, que vai criar a estrutura inicial do Prisma no projeto.

üì¶ O que esse comando faz:
npx prisma init
Ele vai criar dois arquivos/pastas:

.env ‚Üí onde colocamos a string de conex√£o com o banco de dados

prisma/schema.prisma ‚Üí onde voc√™ define as tabelas do banco usando a linguagem do Prisma (super simples de ler)

üß† Por que isso √© importante?
O arquivo schema.prisma √© onde voc√™ descreve os modelos do seu banco ‚Äî tipo User, Animal, etc.

A partir disso, o Prisma:

Cria as tabelas no banco

Gera o c√≥digo necess√°rio pra voc√™ usar essas tabelas no TypeScript

‚úÖ Etapa 3: Entendendo os arquivos criados
Ap√≥s rodar npx prisma init, ele criou:

üìÅ prisma/schema.prisma
Onde voc√™ define os modelos do seu banco ‚Äî como se fossem as ‚Äútabelas‚Äù ou ‚Äúentidades‚Äù.

Aqui voc√™ vai escrever algo como:
model Usuario {
  id    Int     @id @default(autoincrement())
  nome  String
  email String  @unique
}

Esse arquivo vai guiar:

a cria√ß√£o das tabelas no banco,

e a gera√ß√£o dos m√©todos que voc√™ usar√° no c√≥digo (tipo prisma.usuario.findMany())

.env
Arquivo para armazenar vari√°veis sens√≠veis e de ambiente, como a string de conex√£o com o banco.

Por padr√£o, ele j√° tem uma linha assim:
DATABASE_URL="mysql://usuario:senha@localhost:3306/nome_do_banco"
Voc√™ vai ajustar isso pra conectar com seu MySQL.

‚úÖ Etapa 5: Criar o banco api_animais
üìå Por que criar esse banco?
Porque o Prisma precisa que o banco j√° exista antes de gerar as tabelas com migrate.

üõ† Como criar o banco
Voc√™ pode fazer isso de 2 formas:

üíª Op√ß√£o 1: pelo MySQL Workbench (mais visual)
Abre o MySQL Workbench

Clique em Local instance MySQL (ou similar)

Digite a senha de root que voc√™ escolheu

Quando conectar, v√° no canto esquerdo ‚Üí clique com o bot√£o direito em Schemas

Clique em "Create Schema..."

Nomeie como: api_animais

Clique em Apply ‚Üí depois em Finish

üñ•Ô∏è Op√ß√£o 2: via terminal (mais direto)

1: Rode
mysql -u root -p

2: Digite a senha

3: Depois rode:
CREATE DATABASE api_animais;

Etapa 8: Rodar a migra√ß√£o com Prisma
Agora vamos rodar o comando que:

Cria as tabelas Usuario e Animal dentro do banco api_animais

Gera o Prisma Client, que √© o c√≥digo que voc√™ vai usar no seu projeto pra acessar esses dados

 O que √© uma migra√ß√£o?
Migra√ß√£o (ou migration) √© um registro das mudan√ßas na estrutura do banco de dados ao longo do tempo.

üß† Pense assim:
Seu schema.prisma define o modelo do banco no c√≥digo.

A migra√ß√£o:

compara o que est√° no c√≥digo com o que est√° no banco

gera instru√ß√µes SQL pra aplicar essa mudan√ßa no banco

e guarda isso num arquivo de controle

‚úÖ Por que usar migra√ß√£o?
Vantagem	Explica√ß√£o
Controle de vers√£o	Sabe quando e por que uma tabela foi criada, alterada, etc.
Trabalho em equipe	Todos os devs aplicam a mesma estrutura, na mesma ordem
Seguran√ßa	Evita alterar tabelas manualmente no banco e esquecer
Rollback	Voc√™ pode desfazer mudan√ßas se der problema

üóÇÔ∏è No Prisma:
As migra√ß√µes ficam salvas na pasta prisma/migrations

Cada pasta tem data, nome (init, add-animais, etc.) e um .sql gerado automaticamente

‚úÖ Etapa 8: Rodar a migra√ß√£o com Prisma
Agora vamos rodar o comando que:

Cria as tabelas Usuario e Animal dentro do banco api_animais

Gera o Prisma Client, que √© o c√≥digo que voc√™ vai usar no seu projeto pra acessar esses dados

üì¶ Comando:
npx prisma migrate dev --name init

üß† O que esse comando faz?
migrate dev: executa a cria√ß√£o das tabelas com base no schema.prisma

--name init: d√° um nome pra essa ‚Äúvers√£o‚Äù do banco (pode ser qualquer nome, tipo init, primeira-migracao, etc.)

Esse comando tamb√©m atualiza o Prisma Client automaticamente, ent√£o voc√™ j√° pode usar ele no seu c√≥digo.

‚úÖ O que esperar:
Uma pasta prisma/migrations ser√° criada com os arquivos de controle da estrutura do banco

Uma mensagem tipo:
‚úî The following migration(s) have been applied: ...

E seu banco api_animais estar√° com as tabelas prontas